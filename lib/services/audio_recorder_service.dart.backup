import 'dart:io';
import 'package:flutter_sound/flutter_sound.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:path_provider/path_provider.dart';
import '../constants/app_constants.dart';

/// Servicio para gestionar grabaciones de audio
class AudioRecorderService {
  final FlutterSoundRecorder _recorder = FlutterSoundRecorder();
  bool _isInitialized = false;
  String? _currentRecordingPath;
  
  FlutterSoundRecorder get recorder => _recorder;
  String? get currentRecordingPath => _currentRecordingPath;
  bool get isInitialized => _isInitialized;

  /// Inicializa el grabador y solicita permisos
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    
    try {
      // Solicitar permisos
      final micStatus = await Permission.microphone.request();
      final storageStatus = await Permission.storage.request();
      
      if (!micStatus.isGranted) {
        print('‚úó Permiso de micr√≥fono denegado');
        return false;
      }
      
      if (!storageStatus.isGranted) {
        print('‚ö†Ô∏è Permiso de almacenamiento denegado');
      }
      
      // Abrir sesi√≥n de grabaci√≥n
      await _recorder.openRecorder();
      _isInitialized = true;
      print('‚úì Grabador inicializado correctamente');
      return true;
    } on Exception catch (e) {
      print('‚úó Error al inicializar grabador: $e');
      return false;
    }
  }

  /// Inicia la grabaci√≥n
  Future<String?> startRecording() async {
    if (!_isInitialized) {
      final initialized = await initialize();
      if (!initialized) {
        print('‚ö†Ô∏è No se pudo inicializar el grabador');
        return null;
      }
    }
    
    try {
      final path = await _getRecordingPath();
      await _recorder.startRecorder(
        toFile: path,
        codec: Codec.aacADTS,
      );
      _currentRecordingPath = path;
      
      print('‚úì Grabaci√≥n iniciada: $path');
      return path;
    } on Exception catch (e) {
      print('‚úó Error al iniciar grabaci√≥n: $e');
      return null;
    }
  }

  /// Detiene la grabaci√≥n y renombra el archivo a MP3
  Future<RecordingResult> stopRecording() async {
    try {
      await _recorder.stopRecorder();
      
      if (_currentRecordingPath == null) {
        print('‚ö†Ô∏è No hay grabaci√≥n activa');
        return RecordingResult(
          success: false, 
          message: 'No hay grabaci√≥n activa',
        );
      }
      
      // Verificar que el archivo AAC existe
      final audioFile = File(_currentRecordingPath!);
      final exists = await audioFile.exists();
      
      if (!exists) {
        print('‚úó Error: El archivo AAC no se cre√≥');
        return RecordingResult(
          success: false,
          message: 'Error: El archivo no se cre√≥ correctamente',
        );
      }
      
      final aacSize = await audioFile.length();
      print('===================================');
      print('‚úì Grabaci√≥n AAC completada');
      print('Tama√±o AAC: $aacSize bytes');
      print('Ruta AAC: $_currentRecordingPath');
      print('===================================');
      
      // Renombrar AAC a MP3
      print('ÔøΩ Renombrando a .mp3...');
      final mp3Path = await _converter.renameAacToMp3(_currentRecordingPath!);
      
      if (mp3Path == null) {
        print('‚ö†Ô∏è El renombrado fall√≥, se mantiene el archivo AAC');
        return RecordingResult(
          success: true,
          path: _currentRecordingPath,
          fileSize: aacSize,
          message: 'Audio guardado: $aacSize bytes\n$_currentRecordingPath',
        );
      }
      
      // Verificar el archivo MP3
      final mp3File = File(mp3Path);
      final mp3Size = await mp3File.length();
      
      print('===================================');
      print('‚úÖ Archivo guardado como MP3');
      print('Tama√±o: $mp3Size bytes');
      print('Ruta: $mp3Path');
      print('===================================');
      
      return RecordingResult(
        success: true,
        path: mp3Path,
        fileSize: mp3Size,
        message: 'Audio guardado: $mp3Size bytes\n$mp3Path',
      );
    } on Exception catch (e) {
      print('‚úó Error al detener grabaci√≥n: $e');
      return RecordingResult(
        success: false, 
        message: 'Error al detener la grabaci√≥n: $e',
      );
    }
  }

  /// Obtiene la lista de grabaciones
  Future<List<FileInfo>> getRecordings() async {
    try {
      final recordingsDir = await _getRecordingsDirectory();
      
      if (!await recordingsDir.exists()) {
        print('‚ÑπÔ∏è Carpeta de grabaciones no existe a√∫n');
        return [];
      }
      
      final files = recordingsDir.listSync()
          .whereType<File>()
          .where((file) => file.path.endsWith(AppConstants.audioFileExtension))
          .toList();
      
      final fileInfoList = <FileInfo>[];
      for (final file in files) {
        final size = await file.length();
        final name = file.path.split('/').last;
        fileInfoList.add(FileInfo(path: file.path, name: name, size: size));
      }
      
      // Ordenar por fecha (m√°s reciente primero)
      fileInfoList.sort((a, b) => b.path.compareTo(a.path));
      
      print('===================================');
      print('üìÅ Carpeta: ${recordingsDir.path}');
      print('üìä Total de archivos: ${fileInfoList.length}');
      for (final file in fileInfoList) {
        print('  ‚Ä¢ ${file.name} (${file.size} bytes)');
      }
      print('===================================');
      
      return fileInfoList;
    } on Exception catch (e) {
      print('‚úó Error al listar grabaciones: $e');
      return [];
    }
  }

  /// Obtiene el directorio de grabaciones
  Future<Directory> _getRecordingsDirectory() async {
    if (Platform.isAndroid) {
      return Directory('${AppConstants.androidDownloadPath}/${AppConstants.recordingsFolder}');
    } else {
      final appDocDir = await getApplicationDocumentsDirectory();
      return Directory('${appDocDir.path}/${AppConstants.recordingsFolder}');
    }
  }

  /// Genera la ruta para una nueva grabaci√≥n
  Future<String> _getRecordingPath() async {
    final recordingsDir = await _getRecordingsDirectory();
    
    // Crear directorio si no existe
    if (!await recordingsDir.exists()) {
      await recordingsDir.create(recursive: true);
    }
    
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final filename = '${AppConstants.audioFilePrefix}$timestamp${AppConstants.audioFileExtension}';
    return '${recordingsDir.path}/$filename';
  }

  /// Libera recursos
  Future<void> dispose() async {
    if (_isInitialized) {
      await _recorder.closeRecorder();
      _isInitialized = false;
    }
  }
}

/// Resultado de una operaci√≥n de grabaci√≥n
class RecordingResult {
  final bool success;
  final String? path;
  final int? fileSize;
  final String message;
  
  RecordingResult({
    required this.success,
    this.path,
    this.fileSize,
    required this.message,
  });
}

/// Informaci√≥n de un archivo de audio
class FileInfo {
  final String path;
  final String name;
  final int size;
  
  FileInfo({
    required this.path,
    required this.name,
    required this.size,
  });
}
